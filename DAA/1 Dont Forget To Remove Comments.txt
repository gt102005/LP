============================================================
1ï¸âƒ£ FIBONACCI SERIES (fibonacci.py)
============================================================

ğŸ¯ GOAL:
Compute the n-th Fibonacci number using:
   â€¢ Iterative Dynamic Programming
   â€¢ Recursive approach with caching

------------------------------------------------------------
ğŸ“˜ MAIN FUNCTIONS
------------------------------------------------------------
1. fibonacci_iterative(n)
2. fibonacci_recursive(n)
3. helper(n, cache)

------------------------------------------------------------
âš™ï¸ FUNCTION DESCRIPTIONS

ğŸ”¹ fibonacci_iterative(n)
Uses a bottom-up DP list `dp`:
   dp[i] = dp[i-1] + dp[i-2]
Returns dp[n-1] (the nth Fibonacci number).

Time: O(n)
Space: O(n)

ğŸ”¹ fibonacci_recursive(n)
Uses recursion with a predefined cache {1:0, 2:1}.
No updates to cache â†’ behaves like standard recursion.

Time: O(2â¿)
Space: O(n)

------------------------------------------------------------
ğŸ’» EXAMPLE RUN
Input:
Enter value of n(nth Fibonacci number): 7

Output:
Fibonacci Number(Iterative): 8
Fibonacci Number(Recursive): 8

Explanation:
Fibonacci sequence = 0, 1, 1, 2, 3, 5, 8

------------------------------------------------------------
ğŸ§  FUNCTION PURPOSE:
Demonstrates both iterative DP and recursive Fibonacci computation.

------------------------------------------------------------


============================================================
2ï¸âƒ£ HUFFMAN ENCODING (huffman_encoding.py)
============================================================

ğŸ¯ GOAL:
Compress a string using Huffman Encoding â€” a variable-length,
lossless compression algorithm based on character frequency.

------------------------------------------------------------
ğŸ“˜ MAIN CLASSES & FUNCTIONS
------------------------------------------------------------
â€¢ Node class â€” defines Huffman tree nodes.
â€¢ Huffman_Encoding class â€” manages full encoding:
   - char_frequency()
   - build_tree()
   - helper()
   - huffman_encoding()
   - print_encoding()
   - encode()

------------------------------------------------------------
âš™ï¸ FUNCTION DESCRIPTIONS

ğŸ”¹ char_frequency()
Counts each characterâ€™s occurrences and creates Node objects.

ğŸ”¹ build_tree()
Combines two least frequent nodes repeatedly until one node (root) remains.

ğŸ”¹ helper(node, binary_str)
Recursively traverses the tree:
   Left â†’ "0", Right â†’ "1"
Stores binary code for each leaf (character).

ğŸ”¹ print_encoding()
Prints Huffman codes in a table format.

ğŸ”¹ encode()
Executes all steps in sequence.

------------------------------------------------------------
ğŸ’» EXAMPLE RUN
Input:
Enter string to be encoded: AAAAAAABBCCCCCCDDDEEEEEEEEE

Output:
 Char | Huffman code 
 'E'  |           1
 'A'  |          01
 'C'  |         001
 'D'  |        0001
 'B'  |        0000

Explanation:
Frequent letters get shorter codes (E=1, A=01).

------------------------------------------------------------
ğŸ§® COMPLEXITY:
O(n log n)

------------------------------------------------------------
ğŸ§  FUNCTION PURPOSE:
Illustrates greedy compression â€” the basis for ZIP, JPEG, and MP3 encoding.

------------------------------------------------------------


============================================================
3ï¸âƒ£ KNAPSACK PROBLEM (knapsack.py)
============================================================

ğŸ¯ GOAL:
Solve the classical 0/1 Knapsack problem using Dynamic Programming (bottom-up).

------------------------------------------------------------
ğŸ“˜ MAIN FUNCTION
------------------------------------------------------------
knapsack(values, weights, capacity)

------------------------------------------------------------
âš™ï¸ FUNCTION DESCRIPTION

1ï¸âƒ£ Create DP table:
   dp[i][w] = 0 initially, where i = items, w = weight limit.

2ï¸âƒ£ For each item i and capacity w:
   If weights[i-1] <= w:
      dp[i][w] = max(dp[i-1][w],
                     dp[i-1][w-weights[i-1]] + values[i-1])
   Else:
      dp[i][w] = dp[i-1][w]

3ï¸âƒ£ Return dp[-1][-1] â†’ maximum value possible.

------------------------------------------------------------
ğŸ’» EXAMPLE RUN
Input:
Enter number of items: 4
Enter values of items: 10 40 30 50
Enter weights of items: 5 4 6 3
Enter maximum weight: 10

Output:
The maximum value of items that can be carried: 90

------------------------------------------------------------
ğŸ§® COMPLEXITY:
Time: O(n Ã— W)
Space: O(n Ã— W)

------------------------------------------------------------
ğŸ§  FUNCTION PURPOSE:
Dynamic programming optimization â€” shows how to choose items 
for maximum profit within weight constraints.

------------------------------------------------------------


============================================================
4ï¸âƒ£ N-QUEENS PROBLEM (n-queens.py)
============================================================

ğŸ¯ GOAL:
Place N queens on an NÃ—N chessboard so that no two queens threaten each other.

------------------------------------------------------------
ğŸ“˜ MAIN CLASS
------------------------------------------------------------
NQueens
   - printBoard()
   - isSafe(row, col)
   - set_position_first_queen()
   - solve(row)
   - displayMessage()

------------------------------------------------------------
âš™ï¸ FUNCTION DESCRIPTIONS

ğŸ”¹ isSafe(row, col)
Checks same column and both diagonals for existing queens.

ğŸ”¹ solve(row)
Recursive backtracking:
   Try placing a queen column by column.
   If valid â†’ recurse to next row.
   If conflict â†’ backtrack.

ğŸ”¹ displayMessage()
Shows whether a solution exists.

------------------------------------------------------------
ğŸ’» EXAMPLE RUN
Input:
Enter size of chessboard: 4
Enter row (1-4): 1
Enter column (1-4): 2

Output:
X Q X X 
X X X Q 
Q X X X 
X X Q X 

Solution exists for the given position of the queen.

------------------------------------------------------------
ğŸ§® COMPLEXITY:
Time: O(N!)
Space: O(NÂ²)

------------------------------------------------------------
ğŸ§  FUNCTION PURPOSE:
Demonstrates backtracking and constraint satisfaction problems.

------------------------------------------------------------


============================================================
5ï¸âƒ£ 0/1 KNAPSACK (zero_one_knapsack.py)
============================================================

ğŸ¯ GOAL:
Solve the 0/1 Knapsack problem using DP and identify which items 
are selected in the optimal solution.

------------------------------------------------------------
ğŸ“˜ MAIN FUNCTION
------------------------------------------------------------
def knapsack_01(n, values, weights, W)

------------------------------------------------------------
âš™ï¸ FUNCTION DESCRIPTIONS

1ï¸âƒ£ Initialization
   dp = [[0] * (W+1) for _ in range(n+1)]
   â†’ A table of (n+1) rows and (W+1) columns initialized with zeros.

2ï¸âƒ£ Build DP Table
   For each item i (1..n) and capacity w (1..W):
      - If item fits: weights[i-1] <= w
          dp[i][w] = max(dp[i-1][w],
                         dp[i-1][w-weights[i-1]] + values[i-1])
      - Else:
          dp[i][w] = dp[i-1][w]

3ï¸âƒ£ Backtrack to find selected items
   Starting from bottom-right (n, W):
      - If dp[i][w] != dp[i-1][w]:
            Add item (i-1) to selected_items
            Reduce w by weights[i-1]
   Reverse selected_items to show original order.

4ï¸âƒ£ Return
   (dp[n][W], selected_items)

------------------------------------------------------------
ğŸ’» EXAMPLE RUN
Input:
n = 3
values = [60, 100, 120]
weights = [10, 20, 30]
W = 50

Output:
Maximum value: 220
Selected items: [2, 1]

Explanation:
Best selection = items 1 and 2 (0-based index):
â†’ Total weight = 20 + 30 = 50
â†’ Total value = 100 + 120 = 220

------------------------------------------------------------
ğŸ§® COMPLEXITY:
Time: O(n Ã— W)
Space: O(n Ã— W)

------------------------------------------------------------
ğŸ§  FUNCTION PURPOSE:
Improved version of 0/1 Knapsack showing:
- Maximum achievable value
- Which specific items form that optimal result

This mirrors how optimization solvers or inventory systems
determine the best combination of limited resources.

------------------------------------------------------------


============================================================
ğŸ“Š OVERALL SUMMARY
============================================================

| No | Program Name          | Algorithm Type          | Function Purpose                              | Example Output |
|----|------------------------|-------------------------|------------------------------------------------|----------------|
| 1  | fibonacci.py           | DP + Recursion          | Compute nth Fibonacci number                   | 8              |
| 2  | huffman_encoding.py    | Greedy Tree Encoding    | Encode text via frequency-based Huffman codes  | Eâ†’1, Aâ†’01 ...  |
| 3  | knapsack.py            | DP (Tabulation)         | Find max value within weight limit             | 90             |
| 4  | n-queens.py            | Backtracking            | Place N queens safely on board                 | Valid solution |
| 5  | zero_one_knapsack.py   | DP with Backtracking    | Maximize value + track chosen items            | 220, [2,1]     |

------------------------------------------------------------
ğŸ§  KEY CONCEPTS COVERED:
â€¢ Dynamic Programming  
â€¢ Greedy Algorithms  
â€¢ Backtracking Search  
â€¢ Tree Construction & Optimization  
â€¢ Resource Allocation under Constraints
------------------------------------------------------------
