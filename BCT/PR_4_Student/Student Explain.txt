Code: Student.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title Student storage demo - structs, arrays, fallback/receive
contract StudentStorage {
    struct Student {
        uint256 id;
        string name;
        uint8 age;
        string[] courses;
        address studentAddress;
    }

    Student[] public students;
    mapping(uint256 => uint256) private idToIndex; // map id -> index+1 (0 means missing)
    event StudentAdded(uint256 indexed id, string name, address indexed who);
    event FundsReceived(address indexed from, uint256 amount);

    /// @notice Add a student (push to array)
    function addStudent(uint256 _id, string calldata _name, uint8 _age, string[] calldata _courses) external {
        require(_id != 0, "id cannot be 0");
        require(idToIndex[_id] == 0, "Student id exists");
        string[] memory coursesMem = new string[](_courses.length);
        for (uint i = 0; i < _courses.length; i++) {
            coursesMem[i] = _courses[i];
        }
        students.push(Student({
            id: _id,
            name: _name,
            age: _age,
            courses: coursesMem,
            studentAddress: msg.sender
        }));
        idToIndex[_id] = students.length; // index + 1
        emit StudentAdded(_id, _name, msg.sender);
    }

    /// @notice Get total number of students
    function totalStudents() external view returns (uint256) {
        return students.length;
    }

    /// @notice Get student by id; returns tuple (id, name, age, courses, address)
    function getStudent(uint256 _id) external view returns (uint256, string memory, uint8, string[] memory, address) {
        uint256 idx = idToIndex[_id];
        require(idx != 0, "Student not found");
        Student storage s = students[idx - 1];
        return (s.id, s.name, s.age, s.courses, s.studentAddress);
    }

    // Allow contract to receive ETH for demonstration; capture and emit event
    receive() external payable {
        emit FundsReceived(msg.sender, msg.value);
    }

    fallback() external payable {
        emit FundsReceived(msg.sender, msg.value);
    }
}

ðŸ§  Step-by-Step Explanation
1. License & Compiler Version
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;


SPDX-License-Identifier: MIT â†’ Licensing info for open-source.

pragma solidity ^0.8.19; â†’ Uses Solidity compiler version 0.8.19 or above, which provides safety checks and features like overflow protection.

2. Contract Definition
contract StudentStorage {


Defines a smart contract named StudentStorage that manages and stores student data on the Ethereum blockchain.

3. Struct Definition
struct Student {
    uint256 id;
    string name;
    uint8 age;
    string[] courses;
    address studentAddress;
}


A struct defines a custom data type grouping multiple fields.

Field	Type	Description
id	uint256	Unique numeric ID for the student
name	string	Studentâ€™s full name
age	uint8	Age of the student
courses	string[]	List of enrolled course names
studentAddress	address	The Ethereum address of the student (caller who added the record)

ðŸ§© Concept:
This simulates a mini on-chain database using blockchain storage â€” every record added is stored permanently and publicly verifiable.

4. State Variables
Student[] public students;
mapping(uint256 => uint256) private idToIndex;


students: A dynamic array that stores all Student structs.

mapping: Used for quick lookup â€” maps each studentâ€™s id to their position (index + 1) in the array.

If idToIndex[id] == 0, that means the student does not exist.

5. Events
event StudentAdded(uint256 indexed id, string name, address indexed who);
event FundsReceived(address indexed from, uint256 amount);


Events are blockchain logs that external systems (like frontends or explorers) can detect.

Event	Description
StudentAdded	Triggered when a new student is added
FundsReceived	Triggered when someone sends Ether to this contract

ðŸ§© Concept:
Events help track transactions and activity on the blockchain without storing extra data.

6. Adding a Student
function addStudent(uint256 _id, string calldata _name, uint8 _age, string[] calldata _courses) external {
    require(_id != 0, "id cannot be 0");
    require(idToIndex[_id] == 0, "Student id exists");

    string[] memory coursesMem = new string[](_courses.length);
    for (uint i = 0; i < _courses.length; i++) {
        coursesMem[i] = _courses[i];
    }

    students.push(Student({
        id: _id,
        name: _name,
        age: _age,
        courses: coursesMem,
        studentAddress: msg.sender
    }));

    idToIndex[_id] = students.length;
    emit StudentAdded(_id, _name, msg.sender);
}


ðŸ§  Explanation:

Validates that:

ID is not 0.

Student doesnâ€™t already exist.

Copies the _courses array into memory (required in Solidity for dynamic arrays).

Pushes a new Student struct into the array.

Maps ID â†’ index in idToIndex.

Emits an event for blockchain logging.

ðŸ“˜ Concept:
Every call to addStudent() is a blockchain transaction â€” it consumes gas, gets mined, and permanently stores the data.

7. Count Total Students
function totalStudents() external view returns (uint256) {
    return students.length;
}


A simple read-only function that returns how many student records exist.

view â†’ Doesnâ€™t modify blockchain (no gas fee for reading).

8. Retrieve Student by ID
function getStudent(uint256 _id) external view returns (uint256, string memory, uint8, string[] memory, address) {
    uint256 idx = idToIndex[_id];
    require(idx != 0, "Student not found");
    Student storage s = students[idx - 1];
    return (s.id, s.name, s.age, s.courses, s.studentAddress);
}


ðŸ§  Explanation:

Looks up the studentâ€™s index via mapping.

Returns a tuple with all their stored details.

ðŸ“˜ Concept:
Since this function is view, itâ€™s free to call and provides transparency â€” anyone can verify the student data stored on-chain.

9. Receive and Fallback
receive() external payable {
    emit FundsReceived(msg.sender, msg.value);
}

fallback() external payable {
    emit FundsReceived(msg.sender, msg.value);
}


These allow the contract to receive Ether directly.

receive() runs when Ether is sent with no data.

fallback() runs when a function doesnâ€™t exist or Ether is sent with extra data.

Each emits a FundsReceived event to record the sender and amount.

ðŸ§© Concept:
Even though this is a data storage contract, it can still hold ETH â€” like a wallet. This feature demonstrates how contracts can be both data storage + payment receivers.